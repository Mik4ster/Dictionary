Рассмотрим алфавит, состоящий из k букв. Разместить слова длины h в словаре. 
При размещении слов использовать правила составления стандартного словаря.

	Указания к выполнению курсовой работы
1.	Интерпретировать задачу, выданную преподавателем, в терминах теории графов.
2.	Выбрать алгоритм, позволяющий решить данную задачу.
3.	Реализовать алгоритм на выбранном языке программирования.
		Осуществлять задание графа с помощью какой-либо из возможных матриц (смежности, инцидентности, связности, длин ребер).
			По возможности реализовать ввод с помощью оконных форм.
				Предусмотреть возможность ввода разнообразных входных данных.
4.	Реализовать графическое представление введенного графа.
5.	Произвести расчеты по соответствующему алгоритму. 
6.	Реализовать вывод результатов решенной задачи.
7.	Файлы программы после сдачи задания скопировать в папку группы.
		Собственные имена файлов должны соответствовать фамилии студента и номеру варианта задания.
		
Работа представляет собой решение задачи размещения слова в словаре, использую правила составления стандартного словаря.
Размещение, словарь, двоичное дерево поиска, алгоритм, корень, потомок, обход дерева.
Для решения задачи сортировки мы будем использовать так называемое двоичное дерево поиска.

Двоичным деревом поиска называют дерево, все вершины которого упорядочены, каждая вершина имеет не более двух потомков
(назовём их левым и правым), и все вершины, кроме корня, имеют родителя. Вершины, не имеющие потомков, называются листами.
Подразумевается, что каждой вершине соответствует элемент или несколько элементов, имеющие некие ключевые значения,
в дальнейшем именуемые просто ключами. Обычно одной вершине соответствует один элемент, поэтому данные термины можно 
без потери смысла считать синонимами. В нашей задаче считается, что одной вершине соответствует только один элемент - слово. 
Поэтому мы будем использовать понятия ключа вершины и данных вершины, подразумевая ключ и данные соответствующего вершине 
элемента. Мы так же будем понимать под вставкой вершины добавление вершины с указанным значением элемента и присвоение 
указателям на родителя и потомков корректных значений. Именно ключ используется во всех операциях сравнения элементов. 
Элемент может также содержать ассоциированные с ключом данные. На практике в качестве ключа может использоваться часть 
данных элемента. Ключ также может храниться как отдельное значение. Двоичное дерево поиска позволяет выполнять следующие 
основные операции:
- Поиск вершины по ключу;

– Определение вершин с минимальным и максимальным значением ключа;

– Переход к предыдущей или последующей вершине, в порядке, определяемом ключами;

– Вставка вершины;

– Удаление вершины.
Двоичное дерево может быть логически разбито на уровни. Корень дерева является нулевым уровнем, потомки корня - первым уровнем, 
их потомки - вторым, и т.д. Глубина дерева это его максимальный уровень. Понятие глубины также может быть описано
в терминах пути, то есть глубина дерева есть длина самого длинного пути от корня до листа, если следовать
от родительской вершины до потомка. Каждую вершину дерева можно рассматривать как корень поддерева, 
которое определяется данной вершиной и всеми потомками этой вершины, как прямыми, так и косвенными. 
Поэтому о дереве можно говорить как о рекурсивной структуре. Эффективность поиска по дереву напрямую связана с его 
сбалансированностью, то есть с максимальной разницей между глубиной левого и правого поддерева среди всех вершин.
Имеется два крайних случая - сбалансированное бинарное дерево (где каждый уровень имеет полный набор вершин) и 
вырожденное дерево, где на каждый уровень приходится по одной вершине. Вырожденное дерево эквивалентно связанному списку.

Двоичное дерево поиска может быть использовано для реализации таких абстракций, как сортированный список, 
словарь (набор соответствий "ключ-значение"), очередь с приоритетами и так далее.

При реализации дерева помимо значения ключа (key) и данных также хранятся три указателя: 
на родителя (net), левого (left) и правого (right) потомков. 
Если родителя или потомка нет, то указатель хранит нулевое (NULL, NIL) значение.

1.2 Упорядоченность двоичного дерева


Если x - это произвольная вершина в двоичном дереве поиска, а вершина y находится в левом поддереве вершины x, 
то y.key<= x.key. Если x - это произвольная вершина ДДП, а вершина y находится в правом поддереве вершины x, 
то y.key>= x.key. Из свойства следует, что если y.key == x.key, то вершина y может находиться как в левом, 
так и в правом поддереве относительно вершины x.

1.3 Алгоритм


Построение двоичного дерева поиска на основе исходного неотсортированного списка a1, a2, …, aNреализуется на основе 
следующего алгоритма:
1 Для множества, состоящего лишь из одного элемента ai (n=1), a1 просто представляет собой корень, в свою очередь дерево
T1 представляет собой дерево сортировки с одним единственным элементом a1, который является вершиной этого дерева; 
увеличиваем nдо n+1.
2 Если n>N, где, тогда процедура заканчивается. В противном случае сравниваем anс корнем.
Если an?корня, то переходим к левому поддереву.
Если левое поддерево пусто, то добавляем anв качестве левого потомка корня, чтобы формировать следующее дерево сортировки Tn; 
увеличиваем nдо n+1 и повторяем шаг 2;
в противном случае повторяем шаг 2, использую левое поддерево.
В противном случае переходим к правому поддереву.
Если правое поддерево пусто, тогда добавляем an в качестве правого потомка корня, 
чтобы образовать следующее дерево сортировки Tn; увеличиваем n до n+1 и повторяем шаг 2;
В противном случае повторяем шаг 2, используя правое поддерево.

Для того, чтобы составить список вершин дерева сортировки в соответствующем порядке, нужно применить следующие три шага:
1 Обрабатываем левое поддерево;
2 Вносим в список корень;
3 Обрабатываем правое поддерево.

Чтобы обработать поддерево, мы нужно повторить каждый из трех шагов при условии, 
что пустое дерево не нуждается ни в какой обработке.
2.1 Входная и выходная информация

На вход программе подается строка, каждый символ которой ходе работы программы станет элементом алфавита. 
Положение символа в строке определяет его положение в алфавите. Повторение символа в алфавите не допускаются. 
Программирование delphi двоичный
Также задается целое число (hв тексте задания) - длина слова в словаре. Ограничение на длину слова - 99 символов.
Далее на вход подаются непосредственно слова. При наборе слова необходимо использовать только те символы, 
которые содержатся в заданном алфавите.
Выходная информация программы представляет собой список добавленных пользователем слов, 
упорядоченных по правилам составления стандартных словарей.